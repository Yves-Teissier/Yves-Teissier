THEORY ProofList IS
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(17) & WellDefinedness_take.2,(_f(32) => _f(34));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(17) & WellDefinedness_take.1,(_f(32) => _f(33));
_f(1) & _f(2) & _f(3) & _f(9) & WellDefinednessInvariant.1,(_f(28) & _f(29) & _f(30) => _f(31));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(11) & _f(23) & Operation_query.2,(_f(25) & _f(4) => _f(27));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(11) & _f(23) & Operation_query.1,(_f(24) & _f(4) => _f(26));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(17) & _f(18) & Operation_take.4,(_f(4) => _f(22));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(17) & _f(18) & Operation_take.3,(_f(4) => _f(21));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(17) & _f(18) & Operation_take.2,(_f(4) => _f(20));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(17) & _f(18) & Operation_take.1,(_f(4) => _f(19));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(11) & _f(12) & Operation_put.4,(_f(4) => _f(16));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(11) & _f(12) & Operation_put.3,(_f(4) => _f(15));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(11) & _f(12) & Operation_put.2,(_f(4) => _f(14));
_f(1) & _f(2) & _f(3) & _f(9) & _f(10) & _f(11) & _f(12) & Operation_put.1,(_f(4) => _f(13));
_f(1) & _f(2) & _f(3) & Initialisation.4,(_f(4) => _f(8));
_f(1) & _f(2) & _f(3) & Initialisation.3,(_f(4) => _f(7));
_f(1) & _f(2) & _f(3) & Initialisation.2,(_f(4) => _f(6));
_f(1) & _f(2) & _f(3) & Initialisation.1,(_f(4) => _f(5))
END
&
THEORY Formulas IS
((NAT) = (((0) .. (2147483647)))) & ((INT) = (((-2147483647) .. (2147483647))));
ITEM: FIN(INTEGER) & not(ITEM = {}) & ((limit) : ((NAT-{0})));
((ee) : (ITEM));
"Refinement is correct";
(((((0) .. (limit)) * ({ee}))) : (((((0) .. (limit))) --> (ITEM))));
((0) : (((0) .. (limit))));
((0) = (size({})));
(({}) = (((((1) .. (0))) <| ((((0) .. (limit)) * ({ee}))))));
pile : NATURAL-{0} +-> ITEM & ((pile) : (seq(ITEM))) & (size(pile) <= limit);
pilearr$1 : ((0) .. (limit)) +-> ITEM & dom(pilearr$1) = ((0) .. (limit)) & ((pilearr$1) : (((((0) .. (limit))) --> (ITEM)))) & ((counter$1) : (((0) .. (limit)))) & ((counter$1) = (size(pile))) & ((pile) = (((((1) .. (counter$1))) <| (pilearr$1))));
((ii) : (ITEM));
(size(pile) +1 <= limit);
((((pilearr$1) <+ (({(((counter$1 + 1)) |-> (ii))})))) : (((((0) .. (limit))) --> (ITEM))));
(((counter$1 + 1)) : (((0) .. (limit))));
(((counter$1 + 1)) = (size(((pile) <- (ii)))));
((((pile) <- (ii))) = (((((1) .. ((counter$1 + 1)))) <| (((pilearr$1) <+ (({(((counter$1 + 1)) |-> (ii))})))))));
not(((pile) = ({})));
((ii) = (ii$1));
(((counter$1 - 1)) : (((0) .. (limit))));
(((counter$1 - 1)) = (size(front(pile))));
((front(pile)) = (((((1) .. ((counter$1 - 1)))) <| (pilearr$1))));
((last(pile)) = ((pilearr$1 )(counter$1)));
((bb) = (bb$1));
((ii) : ((pilearr$1 )[((1) .. (counter$1))]));
not(((ii) : ((pilearr$1 )[((1) .. (counter$1))])));
((ii) : (ran(pile)));
not(((ii) : (ran(pile))));
pilearr$1 : ((0) .. (limit)) +-> ITEM & dom(pilearr$1) = ((0) .. (limit)) & ((pilearr$1) : (((((0) .. (limit))) --> (ITEM))));
((counter$1) : (((0) .. (limit))));
"Invariant is well defined";
((pile) : (seq(ran(pile))));
"Operation is well defined";
((counter$1) : (dom(pilearr$1)));
((pilearr$1) : (((dom(pilearr$1)) +-> (ran(pilearr$1)))))
END
&
THEORY EnumerateX
END

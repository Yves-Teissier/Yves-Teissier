THEORY ProofList IS
_f(1) & _f(2) & _f(3) & _f(10) & WellDefinednessInvariant.1,(_f(34) & _f(35) => _f(36));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(12) & _f(29) & _f(30) & Operation_leave.3,(_f(31) & _f(6) => _f(33));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(12) & _f(29) & _f(30) & Operation_leave.2,(_f(31) & _f(6) => _f(32));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(12) & _f(29) & _f(30) & Operation_leave.1,(_f(24) => _f(31));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(19) & _f(20) & _f(21) & Operation_dock.5,(_f(22) & _f(23) & _f(6) => _f(28));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(19) & _f(20) & _f(21) & Operation_dock.4,(_f(22) & _f(23) & _f(6) => _f(27));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(19) & _f(20) & _f(21) & Operation_dock.3,(_f(22) & _f(23) & _f(6) => _f(26));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(19) & _f(20) & _f(21) & Operation_dock.2,(_f(22) & _f(23) & _f(6) => _f(25));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(19) & _f(20) & _f(21) & Operation_dock.1,(_f(24) => _f(22));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(12) & _f(13) & _f(14) & _f(15) & Operation_arrive.3,(_f(6) => _f(18));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(12) & _f(13) & _f(14) & _f(15) & Operation_arrive.2,(_f(6) => _f(17));
_f(1) & _f(2) & _f(3) & _f(10) & _f(11) & _f(12) & _f(13) & _f(14) & _f(15) & Operation_arrive.1,(_f(6) => _f(16));
_f(1) & _f(2) & _f(3) & Initialisation.3,(_f(4) & _f(5) & _f(6) => _f(9));
_f(1) & _f(2) & _f(3) & Initialisation.2,(_f(4) & _f(5) & _f(6) => _f(8));
_f(1) & _f(2) & _f(3) & Initialisation.1,(_f(4) & _f(5) & _f(6) => _f(7))
END
&
THEORY Formulas IS
((NAT) = (((0) .. (2147483647)))) & ((INT) = (((-2147483647) .. (2147483647))));
SHIP: FIN(INTEGER) & not(SHIP = {}) & QUAY: FIN(INTEGER) & not(QUAY = {});
list$1 : NATURAL-{0} +-> SHIP & ((list$1) : (seq(SHIP))) & ((fun$1) : (((SHIP) +-> (QUAY))));
{} : NATURAL-{0} +-> SHIP & (({}) : (seq(SHIP)));
(({}) : (((SHIP) +-> (QUAY))));
"Refinement is correct";
((0) : (NAT));
((0) = (size({})));
((({})~) = ({}));
waiting : seq(SHIP) & waiting : NATURAL-{0} +-> SHIP & waiting ~ : SHIP +-> NATURAL-{0} & ((waiting) : (iseq(SHIP))) & docked : QUAY +-> SHIP & docked~ : SHIP +-> QUAY & ((docked) : (((QUAY) >+> (SHIP)))) & ((((ran(waiting)) /\ (ran(docked)))) = ({}));
((num$1) : (NAT)) & ((num$1) = (size(waiting))) & ((waiting) = (list$1)) & (((docked)~) = (fun$1));
((ss) : (SHIP));
not(((ss) : (ran(waiting))));
not(((ss) : (ran(docked))));
(card(waiting) +1 <= 2147483647);
(((num$1 + 1)) : (NAT));
(((num$1 + 1)) = (size(((waiting) <- (ss)))));
((((waiting) <- (ss))) = (((list$1) <- (ss))));
not(((waiting) = ({})));
((qq) : (QUAY));
not(((qq) : (dom(docked))));
not(((list$1) = ({})));
((first(list$1)) : (SHIP));
"Precondition predicate";
(((num$1 - 1)) : (NAT));
(((num$1 - 1)) = (size(tail(waiting))));
((tail(waiting)) = (tail(list$1)));
(((((docked) <+ (({((qq) |-> (first(waiting)))}))))~) = (((fun$1) <+ (({((first(list$1)) |-> (qq))})))));
((ss) : (ran(docked)));
((qq) = (qq$1));
((ss) : (dom(fun$1)));
(((((docked) |>> (({ss}))))~) = (((({ss})) <<| (fun$1))));
((((docked)~ )(ss)) = ((fun$1 )(ss)));
((num$1) : (NAT));
"Invariant is well defined";
((waiting) : (seq(ran(waiting))))
END
&
THEORY EnumerateX
END
